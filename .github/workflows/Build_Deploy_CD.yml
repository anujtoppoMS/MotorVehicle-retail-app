name: Docker Image CI

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

jobs:

  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4

    - name: Build the Docker image
      run: |
        echo ${{ secrets.AZURE_SECRET }} | docker login -u ${{ secrets.ACR_USERNAME }} --password-stdin monarch.azurecr.io
        docker compose --file docker-compose-deploy.yaml up --build -d
        container_name=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep -i billing)
        docker tag $container_name monarch.azurecr.io/$container_name
        docker push monarch.azurecr.io/$container_name
        container_name=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep -i proxy)
        docker tag $container_name monarch.azurecr.io/$container_name
        docker push monarch.azurecr.io/$container_name

  deploy:
    runs-on: ubuntu-latest
    needs: build

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      
    - name: Set up Kubectl
      uses: azure/setup-kubectl@v4

    - name: Set Context for Kubernetes
      uses: Azure/k8s-set-context@v4
      with:
        kubeconfig: ${{ secrets.KUBE_CONFIG }}
        
    - name: Deploy to AKS
      uses: Azure/k8s-deploy@v4
      with:
        action: deploy
        manifests: | 
          pvc.yaml 
          config_name=$(kubectl get configmap | grep env-config)
          if [ -z $config_name ]; then
            kubectl create configmap env-config --from-env-file=.env
          else
            kubectl create configmap env-config --from-env-file=.env --dry-run=client -o yaml > env-config.yaml
          fi
          billing-app.yaml
          ingress.yaml
          
    - name: Verify Deployment 
      run: | 
        kubectl rollout status deployment/billing-app
